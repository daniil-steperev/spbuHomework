# Домашняя работа 3, задание 2 #
Задача: 
> Разработать и реализовать иерархию классов, описывающих дерево
 разбора арифметического выражения. Используя их, реализовать класс,
 вычисляющий значение выражения по дереву. Классы, представляющие
 операнды и операторы, должны сами уметь себя вычислять и печатать.
 Дерево разбора хранится в файле в виде (<операция> <операнд1> <операнд2>),
 где <операнд1> и <операнд2> сами могут быть деревьями, либо числами.
 Например, выражение (1 + 1) * 2 представляется в виде (* (+ 1 1) 2).
 Должны поддерживаться операции {+, -, *, /} и целые числа в качестве
 аргументов. Требуется построить дерево в явном виде, распечатать его
 (не обязательно так же, как во входном файле) и посчитать значение
 выражения обходом дерева. Можно считать, что входной файл корректен.
 Пример — по входному файлу (* (+ 1 1) 2) может печататься ( * ( + 1 1 ) 2 ) и выводиться 4.

Абстрактный класс:
* Node

Используемые классы:
* ExpressionTree
* OperandNode
* OperatorNode
* WrongInputException

> А также тесты к классу ExpressionTree.

### Решение: ###
1. Создаём абстрактный класс Node.
2. Реализуем потомков Node:
   * OperandNode (число)
   * OperatorNode (операция)
   > В классе OperatorNode присутствуют дополнительные методы: SetLeftChild, SetRightChild. В классе OperandNode их нет,
     так как дерево хранится в виде: (<операция> <операнд1> <операнд2>) ,-- следовательно, нет необходимости определять потомков
     OperandNode
3. Создаем класс-исключение WrongInputException. Это исключение должно вызываться, если пользователь ввел некорректное выражение
4. Создаем класс ExpressionTree; разбор дерева происходит по следующему принципу:
   > Операции будут проводиться со строкой (строка считывается из файла)
   * если встретилась открывающаяся скобка -- считать следующий токен:
     + если это операция (+, -, *, /), то вызываем scanTree для левого и правого потомков
     + если это не операция -- выбрасываем исключение WrongInputException
   * если встретилась не открывающаяся скобка -- значит, это число; по схеме Горнера получаем число
   > Метод calculate рекурсивно считает результат арифметического разбора: каждый Node сам вычисляет свое значение (если это
     операция, то применяем ее к обоим потомкам; если число -- возвращаем его) и передает его своему родителю.
   > Метод print рекурсивно печатает дерево: для OperatorNode выводим значения потомков и операцию, для OperandNode -- само значение.
5. Пишем main и тесты к классу ExpressionTree. 